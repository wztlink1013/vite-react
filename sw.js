/*
 * @Description: 
 * @Author: wzt
 * @Date: 2024-09-03 09:49:26
 * @LastEditors: wzt
 * @LastEditTime: 2024-09-03 18:44:43
 */
// ‚úîÔ∏è
const D = Object.defineProperty, // ‰øùÂ≠òÂéüÁîüÁöÑ Object.defineProperty ÊñπÊ≥ï
  // ‚úîÔ∏è
  U = (target, property, value) =>
    property in target
      ? D(target, property, {
          enumerable: true,
          configurable: true,
          writable: true,
          value,
        })
      : (target[property] = value), // ËÆæÁΩÆÂØπË±°Â±ûÊÄßÔºåÂ¶ÇÊûúÂ±ûÊÄßÂ∑≤Â≠òÂú®Âàô‰ΩøÁî® Object.defineProperty ÈáçÊñ∞ÂÆö‰πâÂ±ûÊÄßÔºåÂê¶ÂàôÁõ¥Êé•ËµãÂÄº
  // ‚úîÔ∏è
  k = (target, property, value) => (
    U(target, typeof property !== 'symbol' ? property + '' : property, value),
    value
  ), // ËÆæÁΩÆÂØπË±°Â±ûÊÄßÂπ∂ËøîÂõûËÆæÁΩÆÁöÑÂÄº
  // ‚úîÔ∏è
  R = (target, property, actionDescription) => {
    if (!property.has(target)) throw TypeError(`Cannot ${actionDescription}`);
  }, // Ê£ÄÊü•ÂØπË±°ÊòØÂê¶ÂÖ∑ÊúâÁâπÂÆöÂ±ûÊÄßÔºåÂê¶ÂàôÊäõÂá∫Á±ªÂûãÈîôËØØ
  // ‚úîÔ∏è
  x = (target, property, customReader) => (
    R(target, property, 'read from private field'),
    customReader ? customReader.call(target) : property.get(target)
  ), // Âú®Ê£ÄÊü•ÂØπË±°ÂÖ∑ÊúâÁâπÂÆöÂ±ûÊÄßÂêéËØªÂèñÂ±ûÊÄßÂÄºÔºåÂèØ‰ª•ÈÄöËøáÊèê‰æõÂõûË∞ÉÂáΩÊï∞Êù•ÂÆöÂà∂ËØªÂèñÊñπÂºè
  // ‚úîÔ∏è
  g = (target, propertySet, value) => {
    if (propertySet.has(target))
      throw TypeError('Cannot add the same private member more than once');
    propertySet instanceof WeakSet
      ? propertySet.add(target)
      : propertySet.set(target, value);
  }, // Ê∑ªÂä†ÁßÅÊúâÊàêÂëòÂà∞ÂØπË±°ÔºåÂ¶ÇÊûúÂØπË±°Â∑≤ÂÖ∑ÊúâËØ•ÊàêÂëòÂàôÊäõÂá∫ÈîôËØØÔºåÊîØÊåÅ WeakSet ÂíåÊôÆÈÄö Set ‰∏§ÁßçÂ≠òÂÇ®ÊñπÂºè
  // ‚úîÔ∏è
  u = (target, propertySet, value, customWriter) => (
    R(target, propertySet, 'write to private field'),
    customWriter
      ? customWriter.call(target, value)
      : propertySet.set(target, value),
    value
  ), // Âú®Ê£ÄÊü•ÂØπË±°ÂÖ∑ÊúâÁâπÂÆöÂ±ûÊÄßÂêéÂÜôÂÖ•Â±ûÊÄßÂÄºÔºåÂèØ‰ª•ÈÄöËøáÊèê‰æõÂõûË∞ÉÂáΩÊï∞Êù•ÂÆöÂà∂ÂÜôÂÖ•ÊñπÂºè
  // ‚úîÔ∏è
  E = (target, propertySet, writeAction, readAction) => ({
    set _(newValue) {
      u(target, propertySet, newValue, writeAction);
    },
    get _() {
      return x(target, propertySet, readAction);
    },
  }), // ÂàõÂª∫‰∏Ä‰∏™ÂÖ∑ÊúâËØªÂÜôÂ±ûÊÄß _ ÁöÑÂØπË±°ÔºåÈÄöËøá‰º†ÂÖ•ÁöÑÂèÇÊï∞Êù•ÊéßÂà∂ËØªÂÜôÊìç‰Ωú
  // ${location.origin}
  manifestURL = `/manifest.json`;

let updateInProgress = false,
  isNativeUpdateInProgress = false;

// #region ÁºìÂ≠ò

// ÊâìÂºÄÂêç‰∏∫‚Äúwolai-cache‚ÄùÁöÑÁºìÂ≠ò
const openWolaiCache = () => caches.open('wolai-cache');

// ÊâìÂºÄÂêç‰∏∫‚Äúwolai-meta‚ÄùÁöÑÁºìÂ≠ò
const openWolaiMeta = () => caches.open('wolai-meta');

// Âà†Èô§Âêç‰∏∫‚Äúwolai-cache‚ÄùÁöÑÁºìÂ≠ò
const deleteWolaiCache = () => caches.delete('wolai-cache');

// Âà†Èô§Âêç‰∏∫‚Äúwolai-meta‚ÄùÁöÑÁºìÂ≠ò
const deleteWolaiMeta = () => caches.delete('wolai-meta');

// ‰ªé‚Äúwolai-meta‚ÄùÁºìÂ≠ò‰∏≠Ëé∑ÂèñÂåπÈÖçÁöÑËµÑÊ∫êÂπ∂Ëß£Êûê‰∏∫ JSON
const getFromMetaCache = async (request) => {
  const metaCache = await openWolaiMeta();
  const response = await metaCache.match(request);
  if (response) {
    const text = await response.text();
    return JSON.parse(text);
  } else {
    return null;
  }
};
// Â∞ÜÊï∞ÊçÆÂ≠òÂÖ•‚Äúwolai-meta‚ÄùÁºìÂ≠ò
const putInMetaCache = async (request, data) => {
  const metaCache = await openWolaiMeta();
  try {
    return (
      await metaCache.put(
        request,
        new Response(JSON.stringify(data), {
          headers: { 'content-type': 'text/plain' },
        })
      ),
      true
    );
  } catch (error) {
    return console.error('setMetaItem error ' + error), false;
  }
};

// ÂÖà‰ªéÁºìÂ≠ò‰∏≠Ëé∑ÂèñÊï∞ÊçÆÔºåÁªèËøáÂ§ÑÁêÜÂêéÂÜçÂ≠òÂÖ•ÁºìÂ≠ò
const processAndCache = async (request, processor) => {
  const existingData = await getFromMetaCache(request);
  const processedData = await processor(existingData);
  return (await putInMetaCache(request, processedData)) ? processedData : null;
};

// Ê∏ÖÁ©∫ÊâÄÊúâÁºìÂ≠òÔºåÂ¶ÇÊûúÂ§±Ë¥•ÊâìÂç∞ÈîôËØØ‰ø°ÊÅØ
const clearAllCache = async () => {
  try {
    await Promise.all([deleteWolaiMeta(), deleteWolaiCache()]);
    console.error('üìõ Ê∏ÖÁ©∫ÊâÄÊúâÁöÑÁºìÂ≠òÊàêÂäü');
  } catch (error) {
    console.error('‚ùå Ê∏ÖÁ©∫ÊâÄÊúâÁöÑÁºìÂ≠òÂ§±Ë¥•', error);
  }
};

// #endregion

// #region ÈòüÂàóË∞ÉÂ∫¶

// ÂÆö‰πâÈòüÂàóËäÇÁÇπÁ±ª
class QueueNode {
  constructor(value) {
    k(this, 'value');
    k(this, 'next');
    this.value = value;
  }
}

// ÂÆö‰πâÂº±ÂºïÁî®ÁöÑÁßÅÊúâÊàêÂëòÂèòÈáè
const queueStartMap = new WeakMap();
const queueEndMap = new WeakMap();
const queueSizeMap = new WeakMap();

// ÂÆö‰πâÈòüÂàóÁ±ª
class Queue {
  constructor() {
    // ‰ΩøÁî® WeakMap Â≠òÂÇ®ÁßÅÊúâÊàêÂëòÔºåÈÅøÂÖçÂÜÖÂ≠òÊ≥ÑÊºè
    g(this, queueStartMap, void 0);
    g(this, queueEndMap, void 0);
    g(this, queueSizeMap, 0);
    this.clear();
  }

  enqueue(item) {
    const newNode = new QueueNode(item);
    const firstNode = x(this, queueStartMap);
    if (firstNode) {
      // Â¶ÇÊûúÈòüÂàó‰∏ç‰∏∫Á©∫ÔºåÂ∞ÜÊñ∞ËäÇÁÇπËøûÊé•Âà∞ÈòüÂ∞æÔºåÂπ∂Êõ¥Êñ∞ÈòüÂ∞æÊåáÈíà
      x(this, queueEndMap).next = newNode;
      u(this, queueEndMap, newNode);
    } else {
      // Â¶ÇÊûúÈòüÂàó‰∏∫Á©∫ÔºåÊñ∞ËäÇÁÇπÊó¢ÊòØÈòüÈ¶ñ‰πüÊòØÈòüÂ∞æ
      u(this, queueStartMap, newNode);
      u(this, queueEndMap, newNode);
    }
    // Â¢ûÂä†ÈòüÂàóÈïøÂ∫¶ËÆ°Êï∞
    E(this, queueSizeMap)._++;
  }

  dequeue() {
    const firstNode = x(this, queueStartMap);
    if (firstNode) {
      // ÁßªÈô§ÈòüÈ¶ñËäÇÁÇπÔºåÊõ¥Êñ∞ÈòüÈ¶ñÊåáÈíàÔºåÂπ∂ÂáèÂ∞ëÈòüÂàóÈïøÂ∫¶ËÆ°Êï∞
      u(this, queueStartMap, x(this, queueStartMap).next);
      E(this, queueSizeMap)._--;
      return firstNode.value;
    }
    return null;
  }

  clear() {
    u(this, queueStartMap, void 0);
    u(this, queueEndMap, void 0);
    u(this, queueSizeMap, 0);
  }

  get size() {
    return x(this, queueSizeMap);
  }

  // ÂÆûÁé∞Ëø≠‰ª£Âô®Ôºå‰ª•‰æøÈÅçÂéÜÈòüÂàó
  *[Symbol.iterator]() {
    let currentNode = x(this, queueStartMap);
    for (; currentNode; ) {
      yield currentNode.value;
      currentNode = currentNode.next;
    }
  }
}
// class QueueNode {
//   constructor(e) {
//     k(this, 'value');
//     k(this, 'next');
//     this.value = e;
//   }
// }
// var l, f, h;
// class Queue {
//   constructor() {
//     g(this, l, void 0);
//     g(this, f, void 0);
//     g(this, h, void 0);
//     this.clear();
//   }
//   enqueue(e) {
//     const n = new QueueNode(e);
//     x(this, l)
//       ? ((x(this, f).next = n), u(this, f, n))
//       : (u(this, l, n), u(this, f, n)),
//       E(this, h)._++;
//   }
//   dequeue() {
//     const e = x(this, l);
//     if (e) return u(this, l, x(this, l).next), E(this, h)._--, e.value;
//   }
//   clear() {
//     u(this, l, void 0), u(this, f, void 0), u(this, h, 0);
//   }
//   get size() {
//     return x(this, h);
//   }
//   *[Symbol.iterator]() {
//     let e = x(this, l);
//     for (; e; ) yield e.value, (e = e.next);
//   }
// }
// (l = new WeakMap()), (f = new WeakMap()), (h = new WeakMap());

const J = {
  bind(t, e, n) {
    return t.bind(n);
  },
};

// ÂàõÂª∫Âπ∂ÂèëÊéßÂà∂ÁöÑ‰ªªÂä°ÈòüÂàó
const createConcurrentQueue = (concurrencyLimit) => {
  if (
    !(
      (Number.isInteger(concurrencyLimit) ||
        concurrencyLimit === Number.POSITIVE_INFINITY) &&
      concurrencyLimit > 0
    )
  ) {
    throw new TypeError('Expected `concurrency` to be a number from 1 and up');
  }
  const taskQueue = new Queue();
  let activeTasksCount = 0;
  const finishTask = () => {
    activeTasksCount--;
    if (taskQueue.size > 0) {
      taskQueue.dequeue()();
    }
  };
  const executeTask = async (taskFunction, onComplete, s) => {
    activeTasksCount++;
    const taskResult = (async () => taskFunction(...s))();
    onComplete(taskResult);
    try {
      await taskResult;
    } catch {}
    finishTask();
  };
  const enqueueTask = (taskFunction, onComplete, args) => {
    // () => executeTask(taskFunction, onComplete, ...args)
    taskQueue.enqueue(J.bind(executeTask.bind(void 0, taskFunction, onComplete, args)));
    (async () => (
      await Promise.resolve(),
      activeTasksCount < concurrencyLimit &&
        taskQueue.size > 0 &&
        taskQueue.dequeue()()
    ))();
  };
  const r = (w, ...i) => new Promise((s) => { enqueueTask(w, s, i) });
  return (
    Object.defineProperties(r, {
      activeCount: {
        get: () => activeTasksCount,
      },
      pendingCount: {
        get: () => taskQueue.size,
      },
      clearQueue: {
        value: () => taskQueue.clear(),
      },
    }),
    r
  )
};

// #endregion

// #region Â∑•ÂÖ∑ÂáΩÊï∞
// Ê£ÄÊü•Â≠óÁ¨¶‰∏≤ÊòØÂê¶ÂåπÈÖçÁªôÂÆöÁöÑËßÑÂàô
function checkAgainstRules(input, rules) {
  try {
    return rules.some((rule) =>
      typeof rule === 'string' ? rule === input : rule.test(input)
    );
  } catch (error) {
    return console.error('üíÄ ÂåπÈÖçËßÑÂàôÂ§±Ë¥•', error), false;
  }
}
function checkURLForManifestRule(url) {
  const { host, protocol, pathname } = new URL(url);
  const allowedProtocols = ['http:', 'https:'];
  const allowedHosts = [
    'wolai.com',
    'www.wolai.com',
    'pre.wolai.com',
    'www1.wolai.com',
    'www2.wolai.com',
    'www3.wolai.com',
    'www-uat.wolai.com',
    'previous.wolai.com',
    'www-test.wolai.com',
    'www-test1.wolai.com',
    'www-test2.wolai.com',
    'www-test3.wolai.com',
    'www-test4.wolai.com',
    'www-test5.wolai.com',
    'www-test-mobile.wolai.com',
    'pre-workspace.dingtalk.com',
    'pre-test-workspace.dingtalk.com',
    'pre-test1-workspace.dingtalk.com',
    '.com',
    'pre-test2-workspace.dingtalk.com',
    'pre-test3-workspace.dingtalk.com',
    'pre-test4-workspace.dingtalk.com',
    'pre-test5-workspace.dingtalk.com',
    'workspace.dingtalk.com',
  ];
  const allowedPaths = [
    '/',
    '/day',
    '/dev',
    '/downloads',
    '/email_activate',
    '/enter',
    '/first',
    '/invitation',
    '/invitationLanding',
    '/login',
    '/logout',
    '/messages',
    '/nav',
    '/new-form',
    '/new',
    '/pricing',
    '/product',
    '/random',
    '/reset_password',
    '/signOutFinish',
    '/signup',
  ]; //  /^/component//, /^/invitation//, /^/public-invitation//, /^/wolai_poster//, /^/wolai_share//, /^/[0-9A-Za-z]{16,32}/?/];
  return (
    checkAgainstRules(protocol, allowedProtocols) &&
    checkAgainstRules(host, allowedHosts) &&
    checkAgainstRules(pathname, allowedPaths)
  );
}
function checkURLForResourceRule(url) {
  const { host, protocol, pathname } = new URL(url);
  const allowedProtocols = ['http:', 'https:'];
  const allowedHosts = [
    'vcdn.wostatic.cn',
    'cdn.wostatic.cn',
    'static-test.wolai.com',
    'cdn.wol-static.com',
    'dev.g.alicdn.com',
    'g.alicdn.com',
  ];
  const allowedPaths = [/.(eot|ttf|woff|woff2|css|js|json)$/i];
  return (
    checkAgainstRules(protocol, allowedProtocols) &&
    checkAgainstRules(host, allowedHosts) &&
    checkAgainstRules(pathname, allowedPaths)
  );
}

// ‰ªéËøúÁ´ØËé∑ÂèñËµÑÊ∫êÂπ∂Ëß£Êûê‰∏∫ JSONÔºåÂ¶ÇÊûúËé∑ÂèñÂ§±Ë¥•ËøîÂõû null
const fetchFromRemote = async (request, options) => {
  try {
    const response = await fetch(request, options);
    return response.ok ? await response.json() : null;
  } catch (error) {
    return console.log('‚ùå Ëé∑ÂèñËøúÁ´Ø manifest Â§±Ë¥• ' + error), null;
  }
};
// Ê†πÊçÆ‰º†ÂÖ•ÁöÑÂèÇÊï∞ËøõË°åÂº∫Âà∂Ê∏ÖÁêÜÁºìÂ≠òÊìç‰Ωú
const forceCleanCache = async (params) => {
  if (params.forceClean) {
    console.log(
      'üöú ÂºÄÂßãÂº∫Âà∂Ê∏ÖÁ©∫ÁºìÂ≠ò, ‰øùÁïôÁâàÊú¨ ' + params.version + ' ' + params.date
    );
    const cachedVersions = (await getFromMetaCache('cached-versions')) || [];
    const targetVersion = cachedVersions.find(
      (item) =>
        item.manifest.date === params.date &&
        item.manifest.version === params.version
    );
    if (targetVersion) {
      await putInMetaCache('cached-versions', [
        { ...targetVersion, active: true },
      ]);
      await cleanObsoleteCache();
    } else {
      console.log('üìõ Ê∏ÖÁ©∫ÊâÄÊúâÁöÑÁºìÂ≠ò');
      await clearAllCache();
    }
  }
};
// ‰ªéÊú¨Âú∞Ëé∑ÂèñÁâπÂÆöÁöÑ manifestÔºåÂ¶ÇÊûúËé∑ÂèñÂ§±Ë¥•ËøîÂõû null
const getLocalManifest = async (version) => {
  try {
    const cachedVersions = (await getFromMetaCache('cached-versions')) || [];
    const manifest =
      cachedVersions.find((item) =>
        version ? item.version === version : item.active
      ) || null;
    return manifest ? manifest.manifest : null;
  } catch (error) {
    return console.log('‚ùå Ëé∑ÂèñÊú¨Âú∞ manifest Â§±Ë¥• ' + error), null;
  }
};
// Âπ∂ÂèëÂú∞Â∞ÜÂ§ö‰∏™ËµÑÊ∫êÂ≠òÂÖ•ÁºìÂ≠òÔºåÂ¶ÇÊûúÊúâ‰ªª‰Ωï‰∏Ä‰∏™ÁºìÂ≠òÂ§±Ë¥•ÂàôËøîÂõû false
const cacheRemoteFiles = async (fileList) => {
  const cache = await openWolaiCache();
  const queue = createConcurrentQueue(12);
  let success = true;
  const tasks = fileList.map((file) =>
    queue(async () => {
      const fileRequest = file.path;
      console.warn('>>> ËøõÂæóÊù•Âêó1 >>>', fileRequest)
      if (!(await cache.match(fileRequest))) {
        try {
          console.warn('>>> ËøõÂæóÊù•Âêó2 >>>', fileRequest)
          const response = await fetch(fileRequest);
          if (response.ok) {
            cache.put(fileRequest, response);
          } else {
            throw new Error('‚ùå Âä†ËΩΩÊñá‰ª∂Â§±Ë¥• ' + fileRequest);
          }
        } catch (error) {
          console.error('‚ùå ÁºìÂ≠òÂ§±Ë¥• ' + error + ' ' + fileRequest);
          success = false;
        }
      }
    })
  );
  return await Promise.all(tasks), success;
};
// ÂàáÊç¢ÁâπÂÆöÁâàÊú¨ÁöÑ manifest ‰∏∫ active Áä∂ÊÄÅÔºåÂ¶ÇÊûúÂ§±Ë¥•ËøîÂõû false
const switchManifestVersion = async (version) => {
  const cachedVersions = (await getFromMetaCache('cached-versions')) || [];
  console.warn('>>> ÂàáÊç¢ÁâπÂÆöÁâàÊú¨ÁöÑ manifest ‰∏∫ active Áä∂ÊÄÅÔºåÂ¶ÇÊûúÂ§±Ë¥•ËøîÂõû false >>>', cachedVersions)
  if (!cachedVersions.find((item) => item.version === version)) {
    return console.error('‚ùå ÁõÆÊ†áÁâàÊú¨Êú™ÂÆåÊï¥ÁºìÂ≠ò ' + version), false;
  }
  if (cachedVersions.find((item) => item.version === version && item.active)) {
    return (
      console.log('ÂΩìÂâçÁâàÊú¨Â∑≤ÁªèÊòØ active Áä∂ÊÄÅÔºå‰∏çÈúÄË¶ÅÂàáÊç¢ ' + version), false
    );
  }
  const updatedVersions = cachedVersions.map((item) => ({
    ...item,
    active: false,
  }));
  const targetVersionItem = updatedVersions
    .slice()
    .reverse()
    .find((item) => item.version === version);
  if (targetVersionItem) {
    targetVersionItem.active = true;
    return await putInMetaCache('cached-versions', updatedVersions);
  } else {
    return false;
  }
};
// Ê∏ÖÁêÜËøáÊó∂ÁöÑÁºìÂ≠òÔºåÂ¶ÇÊûúÊ∏ÖÁêÜÊàêÂäüËøîÂõû trueÔºåÂê¶ÂàôËøîÂõû false
const cleanObsoleteCache = async () => {
  const cachedVersions = (await getFromMetaCache('cached-versions')) || [];
  const activeIndex = cachedVersions.findIndex((item) => item.active);
  if (activeIndex === -1) {
    return true;
  }
  const recentVersions = cachedVersions.slice(Math.max(activeIndex - 1, 0));
  if (!(await putInMetaCache('cached-versions', recentVersions))) {
    return console.log('‚ùå Ê∏ÖÁêÜ versions Â§±Ë¥•ÔºåÁ≠âÂæÖ‰∏ãÊ¨°Ê∏ÖÁêÜ'), false;
  }
  const fileMap = recentVersions.reduce(
    (acc, item) =>
      item.manifest.files.reduce(
        (innerAcc, file) => ((innerAcc[file.path] = 1), innerAcc),
        acc
      ),
    {}
  );
  const cache = await openWolaiCache();
  const cacheKeys = await cache.keys();
  const deletionPromises = await Promise.all(
    cacheKeys.map((key) => (fileMap[key.url] ? true : cache.delete(key)))
  );
  const allDeleted = deletionPromises.every((item) => item);
  try {
    const cacheNames = await caches.keys();
    await Promise.all(
      cacheNames
        .filter((name) => name.startsWith('pwa'))
        .map((name) => caches.delete(name))
    );
  } catch (error) {
    console.log('ÁßªÈô§ËÄÅÁâàÊú¨ÁöÑ sw ÁºìÂ≠òÊñá‰ª∂Â§±Ë¥•', error);
  }
  return (
    allDeleted
      ? console.log('üßπ Ê∏ÖÁêÜËøáÊó∂ÁºìÂ≠òÊàêÂäü')
      : console.error('‚ùå Ê∏ÖÁêÜËøáÊó∂ÁºìÂ≠òÂ§±Ë¥•'),
    allDeleted
  );
};
// Ëé∑ÂèñËøúÁ´Ø manifestÔºåÊ†πÊçÆÊÉÖÂÜµÊõ¥Êñ∞ÁºìÂ≠ò„ÄÅÂàáÊç¢ÁâàÊú¨ÊàñÊâìÂç∞ÈîôËØØ‰ø°ÊÅØ
const updateCacheFromRemote = async (optionalParam) => {
  console.log('üîÑ ÂºÄÂßãËé∑ÂèñËøúÁ´Ø manifest');
  const remoteManifest = await fetchFromRemote(optionalParam);
  if (!remoteManifest) {
    return console.error('‚ùå Ëé∑ÂèñËøúÁ´Ø manifest Â§±Ë¥•'), false;
  } else {
    console.warn('‚úÖ Ëé∑ÂèñËøúÁ´Ø manifest ÊàêÂäü', remoteManifest)
  }
  remoteManifest.forceClean && (await forceCleanCache(remoteManifest));
  console.log('üí° Ëé∑ÂèñËøúÁ´Ø manifest ÊàêÂäü, version: ' + remoteManifest.version);
  const localManifest = await getLocalManifest();
  if (!localManifest || localManifest.date !== remoteManifest.date) {
    const dateStr = new Date(remoteManifest.date || 0).toLocaleString();
    console.log(`üåÄ ÊúâÊñ∞ÁâàÊú¨ÔºåÂºÄÂßãÊõ¥Êñ∞ÁºìÂ≠ò ${remoteManifest.version} ${dateStr}`, localManifest);
    const cacheSuccess = await cacheRemoteFiles(remoteManifest.files);
    if (!cacheSuccess) {
      return console.error('‚ùå Ë£ÖËΩΩËøúÁ´ØÊñá‰ª∂Âà∞Êú¨Âú∞ÁºìÂ≠òÁºìÂ≠òÂ§±Ë¥•'), false;
    } else {
      console.warn('‚úÖ Ë£ÖËΩΩËøúÁ´ØÊñá‰ª∂Âà∞Êú¨Âú∞ÁºìÂ≠òÁºìÂ≠òÊàêÂäü', cacheSuccess)
    }
    console.log('üíØ Êñ∞ÁâàÊú¨ÁºìÂ≠òÊàêÂäü ' + remoteManifest.version);
    const switchSuccess = await switchManifestVersion(remoteManifest.version);
    console.warn('>>> Êñ∞ÁâàÊú¨ÁºìÂ≠òÊàêÂäü >>>', switchSuccess)
    if (switchSuccess) {
      console.log(
        'üöÄ ÂàáÊç¢Êñ∞ÁâàÊú¨ÊàêÂäü ' + remoteManifest.version + ' ' + dateStr
      );
    } else {
      console.error('‚ùå ÂàáÊç¢Êñ∞ÁâàÊú¨Â§±Ë¥• ' + remoteManifest.version);
    }
    await cleanObsoleteCache();
  } else {
    await cacheRemoteFiles(localManifest.files);
    const dateStr = new Date(localManifest.date || 0).toLocaleString();
    console.log(
      '‚ú® ÂΩìÂâç‰∏∫ÊúÄÊñ∞ÁâàÊú¨ÁöÑÁºìÂ≠ò ' + remoteManifest.version + ' ' + dateStr
    );
  }
  return true;
};
// ‰∏Ä‰∏™Áî®‰∫éÊõ¥Êñ∞ÁºìÂ≠òÁöÑÂáΩÊï∞ÔºåÁ°Æ‰øùÂè™Êúâ‰∏Ä‰∏™Êõ¥Êñ∞‰ªªÂä°Âú®ËøêË°å
const updateCacheSafely = async (optionalParam) => {
  if (updateInProgress) {
    console.log('üïõ Â∑≤ÁªèÊúâÊõ¥Êñ∞ÁºìÂ≠ò‰ªªÂä°Âú®ËøêË°å‰∏≠');
    return;
  }
  try {
    updateInProgress = true;
    const success = await updateCacheFromRemote(optionalParam);
    return (
      !success && console.error('‚ùå Êõ¥Êñ∞ÁºìÂ≠òÂ§±Ë¥•'),
      (updateInProgress = false),
      success
    );
  } catch (error) {
    return (
      console.error('‚ùå Êõ¥Êñ∞ÁºìÂ≠òÂ§±Ë¥•', error), (updateInProgress = false), false
    );
  }
};
// #endregion

// #region fetch

// Êü•ÊâæÁâπÂÆöÁöÑÊñá‰ª∂Ë∑ØÂæÑÔºåÂ¶ÇÊûúÊâæ‰∏çÂà∞ËøîÂõû null
const findIndexFilePath = async () => {
  const localManifest = await getLocalManifest();
  if (localManifest) {
    const indexFile = localManifest.files.find((item) =>
      /index\.[^.]+\.html/.test(item.path)
    );
    if (indexFile) {
      return indexFile.path;
    }
  }
  return null;
};
// Ëé∑ÂèñËµÑÊ∫êÔºåÂ¶ÇÊûúÊú¨Âú∞ÁºìÂ≠ò‰∏≠ÊúâÂàôËøîÂõûÁºìÂ≠òÁöÑËµÑÊ∫êÔºåÂê¶Âàô‰ªéÁΩëÁªúËé∑ÂèñÂπ∂ÁºìÂ≠ò
const fetchResource = async (request) => {
  const cache = await openWolaiCache();
  const responseFromCache = await cache.match(request);
  if (responseFromCache) {
    return responseFromCache;
  } else {
    const responseFromNetwork = await fetch(request);
    cache.put(request, responseFromNetwork.clone());
    return responseFromNetwork;
  }
};

// Ëé∑ÂèñÁâπÂÆöËµÑÊ∫êÔºåÂ¶ÇÊûúÊú¨Âú∞ÁºìÂ≠ò‰∏≠ÊúâÂàôËøîÂõûÁºìÂ≠òÁöÑËµÑÊ∫êÔºåÂê¶ÂàôËøîÂõûÈªòËÆ§ËµÑÊ∫êÂπ∂Â∞ùËØï‰ªéÁΩëÁªúËé∑ÂèñÂπ∂ÁºìÂ≠ò
const fetchSpecificResource = async (defaultResource) => {
  const indexFilePath = await findIndexFilePath();
  return fetchResource(indexFilePath || defaultResource);
};
// NOTE: Â§ÑÁêÜ fetch ‰∫ã‰ª∂
self.addEventListener('fetch', async (event) => {
  const request = event.request;
  const url = request.url;
  try {
    const { searchParams } = new URL(url);
    if (searchParams.get('sw-bypass')) {
      return;
    }
    if (checkURLForResourceRule(url)) {
      return event.respondWith(fetchResource(request));
    }
    if (!isNativeUpdateInProgress && checkURLForManifestRule(url)) {
      setTimeout(() => updateCacheSafely(manifestURL), 10 * 1000);
      return event.respondWith(fetchSpecificResource(request));
    }
  } catch (error) {
    console.error('üíÄ ËØ∑Ê±ÇÂ§ÑÁêÜÂ§±Ë¥•', error);
  }
});
// #endregion

// #region install
// NOTE: Â§ÑÁêÜ install ‰∫ã‰ª∂
self.addEventListener('install', (event) => {
  event.waitUntil(self.skipWaiting());
});
// #endregion

// #region activate
// NOTE: Â§ÑÁêÜ activate ‰∫ã‰ª∂
self.addEventListener('activate', (event) => {
  console.log('ü•≥ Êñ∞ sw ÊøÄÊ¥ªÊàêÂäü');
  setTimeout(() => updateCacheSafely(manifestURL), 10 * 1000);
  event.waitUntil(self.clients.claim());
});

// #endregion

// #region message
// ÈÅçÂéÜÊâÄÊúâÁ™óÂè£ÂÆ¢Êà∑Á´ØÂπ∂ÂèëÈÄÅÊ∂àÊÅØ
const broadcastMessage = async (message) => {
  try {
    (
      await self.clients.matchAll({ includeUncontrolled: true, type: 'window' })
    ).forEach((client) => client.postMessage(message));
  } catch (error) {
    console.error('broadcast error: ', error);
  }
};
const activateNativeVersion = async (data) => {
  isNativeUpdateInProgress = true;
  const cacheVersions = await processAndCache('cached-versions', (versions) =>
    (versions || []).concat({
      version: data.version,
      date: data.date,
      manifest: data,
      active: false,
    })
  );
  await switchManifestVersion(data.version);
  broadcastMessage({ type: 'NATIVE_CACHED' });
  console.log('üéâ ÊàêÂäüÊøÄÊ¥ª native ÁâàÊú¨' + data.version);
  isNativeUpdateInProgress = false;
};
// NOTE: Â§ÑÁêÜ message ‰∫ã‰ª∂
self.addEventListener('message', async (event) => {
  const message = event.data;
  try {
    switch (message.type) {
      case 'SERVER_INFO':
        await activateNativeVersion(message.body);
        break;
      default:
        console.log('Êú™Â§ÑÁêÜÁöÑ sw Ê∂àÊÅØÁ±ªÂûã' + message.type);
        break;
    }
  } catch (error) {
    console.error('üíÄ sw Ê∂àÊÅØÂ§ÑÁêÜÂ§±Ë¥•', error);
  }
});
// #endregion

// ÂÆöÊó∂ÊâßË°åÊõ¥Êñ∞ÁºìÂ≠ò‰ªªÂä°
setTimeout(() => updateCacheSafely(manifestURL), 1000 * 60 * 0.5);
